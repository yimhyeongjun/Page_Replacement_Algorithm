# Page_Replacement_Algorithm

## 개요
 가상 메모리 관리자의 입장에서 비어 있는 메모리가 많다면 page fault 발생 시 빈 메모리에 page fault된 페이지를 찾아 할당하면 간단하게 해결되는 문제이다. <br>
반면에 메모리 상에 빈 메모리 공간이 거의 없다면 운영체제는 page fault 발생시 다른 페이지를 강제로 페이징 아웃시키고 그 공간에 page fault된 페이지를 할당해야 한다. <br>
이 때 내보낼(evict) 페이지를 운영체제가 선택할 때 기준이 되는 규칙을 ‘페이지 교체 정책(page replacement policy)’이라고 한다. <br>
페이지 교체 정책의 핵심은 ‘내보낼 페이지를 어떻게 결정하는가?’ 이며 내보낼 페이지를 결정하는 기준에 따라 다양한 페이지 교체 알고리즘이 존재한다. <br>
이 프로그램은 Page Replacement Algorithm Simulator로 다양한 페이지 교체 알고리즘을 구현하고 각 페이지 알고리즘에 대한 page fault 횟수를 측정하여 Optimal 알고리즘과 비교한 후 페이지 교체 알고리즘의 성능을 확인해보는 프로그램이다. <br><br>

## 프로그램 기능
 프로그램이 제공하는 기능은 다음과 같다.<br>
1. Optimal 알고리즘과 성능을 비교할 알고리즘을 1~3개 까지 입력 받아 비교한다. 단 모두 선택하는 기능 또한 제공한다.<br>
2. 페이지 프레임의 개수를 3~10개 사이로 입력 받아 알고리즘을 수행한다.<br>
3. 데이터 입력 방식을 난수를 생성하여 저장하는 랜덤 방식과 사용자 생성 파일을 오픈하여 파일 내부에 저장된 데이터를 페이지 스트림으로 사용하는 사용자 생성 방식 중 사용자가 선택한 방식으로 결정한다.<br>
4. 선택한 알고리즘을 실행할 때 페이지 프레임 개수별로 실제 페이지가 교체된 내용과 페이지 폴트 등 시뮬레이션 결과를 단계 별로 출력하고 그 내용을 텍스트 파일에 저장한다.<br><br>

## Page Replacement Algorithm Policy
해당 프로그램에 구현한 '페이지 교체 알고리즘'은 아래 출처를 기반으로 구현하였다.<br><br>

1. Optimal<br>
Optimal 알고리즘의 동작 원리는 다음과 같다.<br>
'교체 정책의 동작 방식을 잘 이해하기 위해서 최적 교체 정책과 비교하는 것이 좋다. 최적 정책은 Belady에 의해 개발되었으며 miss를 최소화하는 정책이다. Belady는 가장 나중에 접근될 페이지를 교체하는 것이 최적이며 가장 적은 횟수의 미스를 발생시킨다는 것을 증명하였다.'<br>
*- Remzi H. Arpaci-Dusseau, Andrea C. Arpaci-Desseau, Operating System: Three Easy Pieces, 도서출판 홍릉(홍릉과학출판사), 2020, p242-244.*<br><br>

2. FIFO<br>
FIFO 알고리즘의 동작 원리는 다음과 같다.<br>
'선입선출 페이지 교체 알고리즘이라고도 하는 FIFO 교체 알고리즘은 시간상으로 메모리에 가장 먼저 들어온 페이지를 대상 페이지로 선정하여 스왑 영역으로 쫓아낸다.'<br>
*- 조성호, 쉽게 배우는 운영체제, 한빛아카데미, 2018, 434p*<br><br>

3. LIFO<br>
LIFO 알고리즘의 작동 방식은 다음과 같다.<br>
'LIFO 알고리즘은 ‘Last In First Out’의 줄임 말로 시간상으로 메모리에 가장 나중에 들어온 페이지를 교체 대상으로 선정하는 알고리즘이다.'<br>
알고리즘 구현 시 참조한 출처는 다음 링크와 같다.<br>
*https://www.youtube.com/watch?v=QEyNUdcBCfA*<br><br>

4. LRU<br>
LRU 알고리즘의 동작 원리는 다음과 같다.<br>
 '최적 근접 알고리즘 중 첫 번째로 살펴볼 LRU 페이지 교체 알고리즘은 ‘최근 최소 사용 페이지 교체 알고리즘’이라고도 한다. 이 알고리즘은 메모리에 올라온 후 가장 오랫동안 사용되지 않은 페이지를 스왑 영역으로 옮긴다. 즉 최근에 사용된 페이지는 놔두고 오래전에 사용된 페이지를 대상 페이지로 선정한다.'<br>
*- 조성호, 쉽게 배우는 운영체제, 한빛아카데미, 2018, 437p*<br><br>

5. LFU<br>
LFU 알고리즘의 동작 원리는 다음과 같다.<br>
 '최적 근접 알고리즘 중 LFU 페이지 교체 알고리즘은 ‘최소 빈도 사용 알고리즘’이라고도 한다. LFU 페이지 교체 알고리즘은 페이지가 몇 번 사용되었는지를 기준으로 대상 페이지를 선정한다. 다시 말해 현재 프레임에 있는 페이지마다 그동안 사용된 횟수를 세어 횟수가 가장 적은 페이지를 스왑 영역으로 옮긴다.'<br>
*- 조성호, 쉽게 배우는 운영체제, 한빛아카데미, 2018, 440p*<br><br>

6. SC<br>
Second Chance 알고리즘은 Clock 알고리즘이라고 불리기도 한다. Clock 알고리즘의 동작 원리는 다음과 같다.<br>
'시계 바늘(Clock hand)이 특정 페이지를 가리킨다고 해보자. 페이지를 교체해야 할 때 운영체제는 현재 바늘이 가리키고 있는 페이지 P의 use bit가 1인지 0인지 검사한다. 만약 1이라면 페이지 P는 최근에 사용되었으며 바람직한 교체 대상이 아니라는 것을 뜻한다. P의 use bit는 0으로 설정되고시계 바늘은 다음 페이지 P+1로 이동한다. 알고리즘은 use bit가 0으로 설정되어 있는, 즉 최근에 사용된 적이 없는 페이지 찾을 때 까지 반복된다.'<br>
*- Remzi H. Arpaci-Dusseau, Andrea C. Arpaci-Desseau, Operating System: Three Easy Pieces, 도서출판 홍릉(홍릉과학출판사), 2020, p253*<br><br>

7. ESC(NUR)<br>
ESC 알고리즘은 NUR 알고리즘이라고 불리기도 한다. ESC 알고리즘의 페이지 교체 동작 원리는 다음과 같다.<br>
'첫 번째 단계로, 현재 포인터 위치에서 포인터를 이동하며 참조와 갱신 비트가 모두 0인 페이지를 찾아 교체하고 다음 페이지로 포인터를 위치시킨다. <br>
첫 번째 단계에서 그런 페이지를 찾지 못하면 두 번째 참조는 0, 갱신은 1로 되어 있는 페이지를 찾아 교체한다. 이 때 포인터를 이동하면서 모든 프레임의 참조 비트를 0으로 바꾼다. 두 번째 단계에서도 해당 페이지를 찾지 못했다면 포인터는 제자리로 돌아와 있을 것이며, 모든 프레임의 참조 비트는 0이 되어 있을 것이므로 다시 첫 번째 단계를 시도하고 안 되면 두 번째 단계까지 시도해 보면 교체 대상 페이지가 발견될 것이다.'<br>
*- 김주균, OS? Oh Yes!: 누워서 보는 운영체제 이야기, 휴먼싸이언스, 2009, p176*<br><br>


## 프로그램 전체 구성도
프로그램의 전체 구성도는 다음과 같다.<br>

![image](https://github.com/yimhyeongjun/Page_Replacement_Algorithm/assets/64363668/df5807a3-5dc3-4c8d-8b60-ddb9c53a561e)

<br>알고리즘과 자료구조의 구현을 각 C파일로 분리하여 구현하였으며 헤더 파일도 구현 후 userlib.h라는 헤더파일에 포함시켜 위와 같은 구조로 구현하였다. 위의 파일들을 Makefile을 통해 컴파일 하도록 구현하였으며 컴파일 결과 생성되는 실행 파일명은 a.out으로 설정하였다.<br><br>

## 알고리즘 성능 테스트 
알고리즘의 page fault 수를 비교하기 위해 시뮬레이션을 진행하였다.<br>
page string은 1~30 사이의 수를 난수로 추출하여 500개의 page stream으로 테스트를 진행하였다.<br>
테스트는 페이지 프레임의 개수를 3부터 10까지 1씩 증가시키며 진행하였다.<br>

![image](https://github.com/yimhyeongjun/Page_Replacement_Algorithm/assets/64363668/56185099-ae63-4a27-9f82-cc1d0b82e649)

![image](https://github.com/yimhyeongjun/Page_Replacement_Algorithm/assets/64363668/c3bc5e5a-a6ad-4c36-a959-3a94c6edf6dd)

![image](https://github.com/yimhyeongjun/Page_Replacement_Algorithm/assets/64363668/8723c940-81e1-48d0-8e4f-b2c83de453ed)

![image](https://github.com/yimhyeongjun/Page_Replacement_Algorithm/assets/64363668/fc2cb57a-8aac-476a-b425-5794017ac05a)

<br><br>
테스트 결과를 알고리즘 별로 비교해보았을 때 확연하게 차이가 나는 알고리즘은 Optimal 알고리즘 뿐이다. Optimal 알고리즘은 모든 페이지 스트림을 안다는 가정 하에 최적의 경우를 수행하기 때문에 앞도적으로 성능이 좋을 수 밖에 없다. 다만 현실에서는 구현될 수 없다.<br>
Optimal 알고리즘을 제외한 나머지 알고리즘은 현실에서 페이지 교체 대상을 선정하는 데 사용될 수 있는데 위 실행 결과를 보게 되면 사실상 차이가 미미하다는 것을 확인할 수 있다. 많은 테스트 케이스를 실행해보지는 않았지만 페이지 스트림에 따라 결과가 달라지기도 하고 모든 경우에서 다른 알고리즘보다 성능이 좋은 경우를 보이는 알고리즘은 없는 것으로 보인다.<br>
